#+TITLE: Euler Library

* Linear Recurrence Closure

If \( a_n \) and \( b_n \) are linear recurrences, then:

1. \( s_n = a_n + b_n \) is a linear recurrence
2. \( p_n = a_nb_n \) is a linear recurrence

** Proof (1) :collapsible:

Let \( C_a(x) \) and \( C_b(x) \) be the characteristic polynomials of \( a_n \) and \( b_n \) respectively.  Then we claim 

\[
C_s(x) = \frac{C_a(x)C_b(x)}{hcf\left(C_a(x), C_b(x)\right)}
\]

We've selected \( C_s(x) \) so that it has the same "solution equation" as \( s_n \) minus the constant coefficients.  Now consider:

\begin{align*}
\left(
  \begin{array}{cccc}
  \lambda_1^n       & n\lambda_1^n           & \cdots    & \lambda_n^n \\
  \lambda_1^{n - 1} & (n - 1)\lambda_1^{n-1} & \cdots    & \lambda_n^{n-1} \\
  \vdots            & \vdots                 & \ddots    & \vdots \\
  \lambda_1         & \lambda_1              & \cdots    & \lambda_n
  \end{array}
\right)
\left(
\begin{array}{c}
   c_n \\
   c_{n - 1} \\
   \vdots \\
   c_1
\end{array}
\right)
= 
\left(
\begin{array}{c}
   s_n \\
   s_{n - 1} \\
   \vdots \\
   s_1
\end{array}
\right)
\end{align*}

Where \( c_i \) are the components of the IC vector, and \( \lambda_k \) form the solution equation of \( s_n \):

\[
s_n = \lambda_1^n + n\lambda_1^n + \cdots + \lambda_n^n
\]

Since the matrix in nonsingular (it is a confluent Vandermonde matrix), its columnspace is maximal and hence there exists an IC vector which satisfies the above.

#+BEGIN_SRC python
import sympy as sp
from sympy import Matrix, Poly

# The base cases
ics1 = [1, 1]
ics2 = [1, 2, 5]

# The recurrences we want to add, defined here for clarity
def a_n(n, ics=ics1):
    if n <= len(ics):
	return ics[n - 1]
    else:
	return a_n(n - 1) + 2*a_n(n - 2)

def b_n(n, ics=ics2):
    if n <= len(ics):
	return ics[n - 1]
    else:
	return 4*b_n(n - 1) - 5*b_n(n - 2) + 2*b_n(n - 3)

x = sp.Symbol("x")
# x_n = x_{n - 1} + 2*x_{n - 2}
char_poly1 = x**2 - x - 2 
# x_n = 4*x_{n - 1} - 5*x{n - 2} + 2*x{n - 3}
char_poly2 = x**3 - 4*x**2 + 5*x - 2

p = Poly(
    sp.simplify(char_poly1 * char_poly2 / sp.gcd(char_poly1, char_poly2))
)
coeffs = p.all_coeffs()
print(p)

# We create the companion matrix of our polynomial
mat = Matrix.diag([1]*(len(coeffs) - 1))
mat.row_del(-1)
mat = mat.row_insert(0, Matrix([[-c for c in coeffs[1:]]]))
print(mat)

# Finally we show n applications of our matrix gives what we expect
ics = Matrix([[a_n(n) + b_n(n)] for n in range(1, len(coeffs))][::-1])
arr = list(ics)[::-1] + [(mat**n * ics)[0] for n in range(1, 10)]
print(arr)
print([a_n(n) + b_n(n) for n in range(1, 14)])
#+END_SRC

#+RESULTS:

* Power Modulo

If \( a \) and \( p \) are coprime then:

\[
a^x \pmod p = a^{x \pmod{\phi (p)}}\pmod p
\]

We can also reduce \( \phi (p) \) to \( |\langle a \rangle | \) if necessary.  More generally if no restrictions are placed on \( a \) and \( p \) then:

\[
a^x \pmod p = \begin{cases}
a^{\left(x\pmod{\phi (p)}\right) + \phi(p)} \pmod p  & \text{for } x \ge \phi(n) \\
a^x \pmod p & \text{for } x < \phi(p)\\
\end{cases}
\]

** Proof (first condition): :collapsible:

Let \( p_1^{e_1}p_2^{e_2}... \) be the prime factorisation of \( p \), and \( e_i' \) be the largest \( e \) s.t. \( p^e | a \).  Consider

\[
a^{\phi(n)} \pmod{p_i^{e_i}} = (\lambda p_i^{e_i'})^{\phi(n)} \pmod{p_i^{e_i}}
\]

Where \( \lambda \) is coprime to \( p \).  Now if \( \phi(n) > e_i \) then 

\[
(\lambda p_i^{e_i'})^{\phi(n)} \equiv 0 \pmod{p_i^{e_i}}
\]

For all nonzero \( e_i' \), ie if \( a \) is \( p \)-free.  We have:

\[
e_i < p^{e_i}(p - 1) = \phi(p^{e_i}) \le \phi(n)
\]

Now consider the simultaneous congruences we have for \( a^{q\phi(n) + r} \), with \( q > 0 \) :

\[
a^{q\phi(n) + r} = \ m_i \pmod{p_i^{e_i}}
\]

For \( p_i \) with \( e_i' > 0 \), we must have \( m_i = 0 \), and so given \( q > 0 \), and applying Euler's Theorem for \( p_i \not | a \), we arrive at the conclusion that the simultaneous congruences do not depend on \( q > 0 \).  From here, applying The Chinese remainder theorem gets us our claim.

* Factorisation in Quadratic Integer Rings

** Gaussian Integers

\( a + bi \in \mathbb{Z}[i]  \) is prime iff one of the components is zero and the other is an associate of a (normal) prime of the form \( 3 \pmod 4 \), or its norm is (a normal) prime.  This follows from the fact that \( p \) can be written as the sum of two squares iff -1 is a quadratic residue modulo \( p \).  Note by [[https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares][Fermat's Two Square Theorem]] we can always write \( p \equiv 1 \pmod 4 \) as a sum of two squares.

It follows we can find the prime factorisation of \( n \in \mathbb{Z} \) by taking its normal factorisation and further decomposing primes of the form \( 1 \pmod 4 \).  Solving \( p = (a + bi)(a - bi) = a^2 + b^2 \) can be done efficiently by first solving for \( x^2 \equiv -1 \pmod p \) (using Tonelli Shanks), we then find \( a + bi = gcd(p, \ x + i) \).
*** Proof :collapsible:
If \( p | x^2 + 1 \) then \( p | (x + i)(x - i) \), arguing for a contradiction we see we cannot have \( p|(x + i) \) or \( p | (x - i) \).  Thus \( gcd(p, \ x + i) \) and \( gcd(p, \ x - i) \) are not units so we can find a proper divisor of \( p \) by computing either of them.  Clearly \( a + bi = gcd(p, x \pm i) \) has nonzero real and imaginary parts (since \( p \) is prime in \( \mathbb{Z}  \)), and so if \( (c + di)(a + bi) = p \) we must have \( c + di = a - bi \) since \( p \) is real.  This completes the proof.


*** Sum of Squares

This gives us a way to compute all the ways in which \( n \) can be written as the sum of squares: https://mathoverflow.net/a/319809/332110.

* Euler Transform

Given we know the number of connected graph \( a_n \) satsifying some property, we can calculate the total number of graphs satsifying the property (\( b_n \)) using the Euler Transform:

\[
b_n = \frac{1}{n} \left( c_n + \sum^{n - 1}_{k=1} c_k b_{n - k} \right)
\]

With

\[
c_n = \sum_{d|n} d a_d
\]

* Floor Sums

We can compute the sum:
\[
D(n) = \sum_{k = 1}^n \left \lfloor \frac{n}{k} \right \rfloor
\]

Also known as the [[https://en.wikipedia.org/wiki/Divisor_summatory_function][Divisor Summatory Function]], in \( O(\sqrt{n}) \) time:

#+begin_src python
def divisor_sum(n):
    u = int(math.sqrt(n))  # equivalent to math.isqrt(n) in python 3.8
    return 2*sum(n//k for k in range(1, u + 1)) - u*u
#+end_src

Also known fast methods to compute \( \sum_{x = 0}^n \left \lfloor \frac{ax + b}{c} \right \rfloor \), \( \sum_{x = 0}^n x \left \lfloor \frac{ax + b}{c} \right \rfloor \), \( \sum_{x = 0}^n \left \lfloor \frac{ax + b}{c} \right \rfloor^2 \) and even more generally \( \sum_{x = 0}^n x^{k_1} \left \lfloor \frac{ax + b}{c} \right \rfloor^{k_2} \), see [[https://asfjwd.github.io/2020-04-24-floor-sum-ap/][this]] blog posts for more details.

* Assorted

- \( f_{n + 1} = a_nf_n + \cdots + a_0f_{n - k} \) is totally periodic modulo \( n \) if \( a_0 \) is a unit in \( \mathbb{Z}_n \) 
